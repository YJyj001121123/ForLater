项目+Cpp+面经
https://github.com/youngyangyang04/TechCPP?tab=readme-ov-file

//针对于ipv4地址不够用的情况，我们是如何解决 --- IPV6 NAT 地址重用和地址共享
//ip地址和mac地址的区别都有那些 --- 
    //MAC地址是网络设备在数据链路层中使用的物理地址，用于唯一标识网络设备。6个十六进制数对
    //IP地址是用于在网络中唯一标识和定位设备的一种地址，网络层协议中使用的一种地址。
//转发和重定向 --- 转发：当服务器收到一个请求时，可以将该请求转发给另一个资源进行处理，但是客户端并不知道这个过程。
            //重定向：重定向会告诉客户端，请求的资源已经被移动到另一个位置。客户端接收到重定向响应后，会自动跳转到新的URL去获取资源
//在TCP拥塞控制中，使用了什么样的算法 --- 慢启动：TCP发送方会以指数增长的速率增加发送窗口
            //快重传：当发送方连续收到三个相同的重复确认时，表明有报文段丢失，发送方会立即重传该丢失的报文段，而不必等待超时重传计时器。
            //快恢复：进行快重传后，TCP发送方会将拥塞窗口大小减半，并进入快恢复状态，此时发送方会继续以线性增长的速率增加发送窗口
//TCP粘包 --- 接收方在一次读取数据时，将多个发送方发送的数据包合并成一个或者少于原始数据包数量的现象。TCP是面向流的传输协议
            //数据包中增加长度字段，让接收方根据长度字段来正确解析数据包。使用特殊标记或分隔符来标识数据包的边界
//TCP流量控制的理解 ---- 调整发送方的发送速率，使其不会发送过多数据导致接收方无法及时处理或网络拥塞的机制 滑动窗口大小
            //发送方根据接收方通知的窗口大小来确定发送数据的数量
//TCP协议是如何保证可靠传输 --- 序列号和确认应答、数据校验和重传机制、滑动窗口和流量控制、拥塞控制
//TCP和UDP对应常见的应用层协议有那些 --- TCP: Http SMATP Websocket UDP：KCP\DNS
//DNS域名缓存 --- 减少对远端DNS服务器的查询次数，加快域名解析速度，减轻DNS服务器的负担
            //浏览器缓存\操作系统缓存\路由器缓存\递归DNS服务器缓存(ISP的DNS服务器\根DNS服务器\顶级域（TLD）服务器\权威DNS服务器)
            //结果返回 访问
//Cookie和Session --- Cookie:存储在客户端（通常是用户的浏览器）上的小型数据片 服务端发送 客户端保存 存储用户偏好
            //session:服务器端用来存储信息的机制 存储用户特定的数据，如购物车内容、用户ID等
//HTTP中常用的状态码 --- 1xx：信息性状态码 100 Continue：客户端应继续其请求
            //2xx：成功 200 OK：请求成功，对GET、PUT、PATCH或POST操作的标准响应
            //3xx：重定向： 301 Moved Permanently：请求的页面已永久移动到新位置
            //4xx：客户端错误  400 Bad Request：服务器无法理解请求的格式，客户端不应该再次尝试发送同样的请求
            //5xx：服务器错误  500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理
//HTTP 方法 --- GET，POST，PUT，DELETE 查 增 改 删
            //  GET: URL中受URL限制 它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态
            //  POST: HTTP包内 可能修改变服务器上的资源的请求，会增加种类
            //  PUT: 向服务器端发送数据的，从而改变信息，不会增加数据的种类。
            //  PATCH: 类似PUT，资源部分的更新
//TCP三次握手 --- TCP三次握手的核心目的在于双向确认通信双方的接收能力 确保双方都准备好进行数据传输，并且同步序列号
//大端和小端模式  ---- 大端：数据的高字节存储在低地址中，低字节存储在高地址中 
            //Intel的x86架构处理器使用小端模式，而IBM的Power Architecture处理器使用大端模式
//Https加密过程 --- 一种通过TLS/SSL加密通信的HTTP协议，用于安全地传输数据
            //建立连接 服务器返回数字证书 包含服务器的公钥 CA（颁发机构） 数字签名
            //验证证书 客户端会检查证书的签名是否有效
            //协商加密算法 确定使用的加密算法、密钥长度、身份验证方法等 TLS 握手（私钥）
            //生成会话密钥 客户端生成一个随机的会话密钥（Session Key）（利用上面的公钥），用于对称加密通信
            //服务端使用私钥解密客户端发送的会话密钥
//SYN队列 --- TCP协议中的连接建立队列。
            //客户端发送SYN（同步）包给服务器，服务器接收到后回复SYN-ACK（同步-确认）包，
            //最后客户端再回复ACK（确认）包，完成三次握手即建立连接
            //发送FIN包 对方ACK包确认 对方发送FIN包  发送ACK包
//keepalive是什么？如何使用 --- 检测两台计算机之间的连接是否仍然活跃 频繁地发送Keepalive探测包
//connect会阻塞怎么解决 --- 使用的是阻塞式套接字，connect会一直阻塞到连接成功或者发生错误为止
            //使用非阻塞套接字 不要主线程就可以
            //使用异步I/O或事件驱动模型 
//time_wait，close_wait状态产生原因 --- TCP连接处于关闭过程中的两种状态
            //TIME_WAIT状态发生在四次挥手过程的最后阶段  确保对方收到最后一个带有ACK标志的TCP包
            //当一方（如客户端）收到另一方发送的具有FIN标志的TCP包，它会发送一个带有ACK标志的TCP包作为确认，并进入TIME_WAIT状态
            //CLOSE_WAIT状态出现在接收到对方发送的带有FIN标志的TCP包时。
            //当一方（如服务器）收到请求关闭连接的FIN包后，它会发送一个带有ACK标志的TCP包进行确认，并进入CLOSE_WAIT状态。

 
//五种IO模式 --- 阻塞I/O 非阻塞I/O I/O多路复用（事件驱动IO、同时监控多个I/O描述符当任何一个I/O描述符准备好数据时，应用程序就可以对其进行处理）
            //信号驱动  应用程序可以向操作系统注册一个信号处理函数，当数据准备好时，操作系统会发送一个信号，应用程序可以在接收到信号时读取数据
            //异步I/O 
//Socket编程 --- 用TCP/IP协议族中的套接字(Socket)接口，实现客户端和服务器之间的数据交换
            // 创建Socket： Socket是通信的端点，用于标识网络上的一个地址和端口
            // 绑定Socket：服务器程序需要将Socket绑定到特定的IP地址和端口号上，以便客户端能够连接到服务器
            // 监听连接：服务器Socket调用listen()函数开始监听来自客户端的连接请求。
            // 接受连接：服务器Socket调用accept()函数接受客户端的连接请求，与客户端建立连接
            // 发送和接收数据： send recv
            // 关闭连接: close
//select模型和poll模型epoll模型 --- select :监视多个文件描述符直到其中一个文件描述符准备好进行某种IO操作（如读或写）为止。使用select模型的优点是跨平台性好
            //每次调用select都需要遍历所有的文件描述符
            //poll模型:没有最大文件描述符数量的限制
            //epoll模型：以红黑树作为底层的数据结构只有当某个文件描述符准备好进行IO操作时，它才会将这个文件描述符添加到就绪列表中，这避免了遍历所有文件描述符的开销
            //水平触发（LT）和边缘触发（ET）

