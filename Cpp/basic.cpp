//
// Created by ByteDance on 2024/4/19.
//
//
/***
 * 1、指针和引用
 * 指针是实体，指向地址，需要内存空间；引用理解为变量的他名字，表示变量，不需要内存空间。
 * 引用必须初始化，不能修改；指针可变。
 * 没有多级引用。&&
 * sizeof获取的是对象本身的大小---引用则是变量，指针则是指针本身。
 * 传指针本质是传值的，传递指针的地址；传引用的实质是传地址，传递的是变量的地址。
 * 值传递：实参->形参。改变形参的值不会改变实参。（函数内部修改，不改变外部）。
 * 指针传递：形参指向实参地址的指针，相当于对实参本身进行操作了。
 * 引用传递：对形参操作其实就是对实参操作。形参虽然作为局部变量分配在栈，但存放的是实参的地址。
 * 2、形参和实参
 * 形参：只有在被调用时才分配内存单元，调用结束时，即刻释放所分配的内存。只在函数内部有效。
 * 实参：可以是常量、变量、表达式、函数等。在进行函数调用时，必须有确定的值。
 * 3、static
 * 隐藏特性：编译多个文件，未加static前缀的全局变量函数都具有全局可见性。
 * 持久性：存储在static数据区的变量在程序开始运行时完成初始化，唯一一次。
 * static数据区会存储全局变量和static变量。
 * 默认性：默认初始化0（全局变量亦是如此）。
 * 类成员声明static：
 * 函数体内，static只作用在函数内，只分配一次内存。
 * 类中的static成员变量属于整个类所有，对类所有对象只有一份拷贝
 * 类中的static成员函数属于整个类所有，函数不接受this指针，只能访问static成员变量。
 * static修饰的变量，类外初始化。
 * static成员函数不能被virtual修饰，static成员不属于任何对象或实例。
 * 虚函数实现是为每一个对象分配一个vptr指针，vptr是通过this指针调用的。
 * 虚函数调用关系：this-->vptr-->ctable-->virtual function
 * C：初始化发生在代码执行前，编译阶段分配好内存才可以初始化。
 * C++：在执行时，才会初始化。C++初始化必须执行构造和析构，可能有特定的操作
 *      通过atexit()管理，可以使用变量对静态局部变量初始化。
 * 4、const
 * 定义为const，初始化后无法改变。
 * 可以指定指针本身为const--> int* const p; 常量指针不能在指向别的变量，但指向（变量）的值可以修改
 * 也可以指定数据const--> const int* p;指向的值不能修改
 * 或者const int* const p;
 * const修饰形参，函数内部不能更改。
 * const int xx(){};常函数，不能修改类的成员变量。
 * const成员函数，可以访问类中全部成员。
 * 非const成员函数，不能访问const相关的。
 * const对象只能调用const成员函数。
 * const_cast 转为非const类型。
 * 引用指针传递时，传进去引用（变量地址）或者指针（指针地址指向变量的地址），函数内部可以改变引用或者指针所指向的变量。
 *      const才保护实参的变量。
 * 5、mutable
 * const成员方法需要修改成员变量的值，修饰为mutable，它不受const限制。
 * 6、extern
 * 调用规范，C++调用C，目的是告诉链接器。
 * 7、深拷贝和浅拷贝
 * 浅拷贝：只拷贝基本类型的数据。仅仅指向被复制的对象的内存地址，如果原地址对象改变，浅拷贝的也会变
 * 深拷贝：开辟一块新的内存地址存放复制的对象。
 * 8、C++函数模板
 * 编译器从函数模版通过类型区生成不同的函数，会进行两次编译：声明地方对模板代码进行编译‘在调用地方替换代码完成编译
 * 函数模版是需要实例化的，如果使用声明和定义不可缺少
 * 9、C struct 和 C++ struct
 * C：用户自定义的数据类型，无权限设置，可以封装但不能隐藏数据，不能有函数。
 * C++：抽象数据类型，默认public，class默认private，可以有成员函数。
 * 10、虚函数可以inline？
 * 虚函数可以是内联函数，inline可以修饰虚函数，但虚函数有多态性就不行了。
 * 内联发现在编译的期间，虚函数多态在运行期。
 * inline virtual唯一使用：编译器指定所调用的对象哪个类，这只有在编译器具有实际对象而不是对象引用或指针时才行。
 * 11、类的初始化
 * 赋值初始化：函数体内进行。所有数据成员被分配内存空间后才行。赋值操作产生临时对象。
 * 列表初始化：冒号后进行。在分配内存空间时就进行初始化。
 * 构造顺序：虚拟基类-->基类-->类类型成员对象-->派生类的构造。。
 * 12、构造函数不能为虚函数，析构函数为什么要虚函数？
 * 虚函数需要对应指向虚表的vptr，vptr需要对象的内存空间。构造时，对象还没有实例化，没有内存空间。
 * 析构需要虚，防止内存泄漏，派生类销毁-->基类销毁.
 * 析构函数没有参数，没有返回，不能重载，一个类只有一个，编译器自动去调用析构。
 * 13、析构和构造可以调用虚函数么？
 * 不提倡。父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编
 * 析构时，子类先被干掉的。
 * 14、构造析构释放抛出异常
 * C++只会析构已经完成的对象，如果构造异常，该对象的析构不会调用，内存泄漏。
 * 15、类如何实现只静态分配或者只能动态分配
 * 16、
 *
 *
 */
