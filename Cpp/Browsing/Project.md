# EventQueue（事件池）
1、功能：
支持在多个生产者和一个消费者的场景下，事件队列来管理存在的积压事件以及插入取出的规则。
2、为什么需要：
实际的工程，消费者执行需要时间，无法保证生产者产生信号之前一组在Wait状态，就会造成信号短缺失。
3、对应实时信号模型：
进程当前正在执行信号处理函数，在处理信号期间接收到了新的信号，如果该信号是信号掩码中的成员，那么内核会将其阻塞，将该信号添加到进程的等待信号集（等待被处理/处于等待状态的信号）中， 为了确定进程中处于等待状态的信号，可以使用 sigpending()函数获取。（缓存状态信号）
4、怎么做：
采用了Windows系统的状态信号模型，如果生产者发出信号，没有消费者等待，系统缓存信号，直到消费者等待了，再发出信号。
所以就并不是单纯的使用信号量进行状态同步，而是对象放入缓冲区，通知消费者线程去检查缓冲区。
通过list缓存对象，任务数量了。行为语义改为“存在还未被消费的信号”和“当前没有被消费的信号”
5、关键行为
Wait：检查并等待新任务的分发
Notify：分发新任务并通知等待的线程
Break ：中断等待的线程
用到了条件变量、互斥锁之类实现。

# TaskQueue(任务队列)
支持在任意线程进行任务的提交，在统一的执行线程进行任务消费的能力。
1、为什么
举个例子：业务方调用 sdk 的接口所在的线程对我们而言是不确定的，需要将业务方对接口的调用转到内部的确定线程，保证数据同步；
还有如果调用业务提供的回调接口，无法保证业务的回调怎么实现的，如果回调线程和主线程不区分，导致主线程卡死了。
2、本质就是对EventQueue（事件池）进行封装。
在发布任务时，将任务适配成std::function<void()>对象，并推送进入EventQueue中，通过在执行线程中循环Wait来从EventQueue中有序获取任务，并执行。
定义一个同步锁对象，利用这个对象创建一个对象传递到线程二，任务执行完成，传入线程二的对象析构，调用jobdone 通知线程一

# LogSDK -- 文件系统 线程 日志 网络通道 对应不同的服务平台
1、本地日志：
对应log_queue去写
Newfile
FileInfo 类用于存储日志文件的路径和创建时间，并实现了一个比较操作符，用于根据创建时间进行排序。
维护list 要写的日志放入list
list的日志写入文件
标准I/O流：整个日志写入过程都是通过标准的C库文件操作函数完成的，如 fopen、fwrite 和 fclose。
2、日志回捞
客户端定时请求服务端，看该设备有无回捞任务
有的话：服务端会发送区间信息下发客户端
客户端传送日志到服务端
服务端把日志放入内置平台 然后发送

Boost.Asio 中的一种 I/O 事件处理机制 非阻塞轮询的处理
资源控制: 轮询可以控制系统资源的使用，避免一次性大量读取日志数据导致系统资源瞬间被占用，影响系统的稳定性和响应性能。没有实时性要求

具体使用了http client：
    日志回捞不期望留下任何的长链接和线程的
实现：
    发送post请求，获取到回捞的任务
    上传回捞的文件

3、上传服务
    埋点 内存、mmap形式写入
    上报采用pb协议定义Metric 数据的消息格式 在客户端将Metric 数据序列化成二进制格式
    服务端反序列化

    客户端降频: 在客户端实现计时器或计数器，控制某些字段的更新频率。例如，每隔一定时间再次上传某些指标，而不是每次数据变化都立即上传。
    服务端降频: 在服务端实现类似的策略，根据字段的最新更新时间或其他条件，决定是否处理接收到的数据。可以记录上次处理时间，并根据一定的时间间隔来过滤不必要的数据处理请求。
# 缓存
KV set/get
windows 注册表
iOS/Mac NSUserDefaults
Android Sharedprefence

meta结构 存放count 时间

已发板SDK如果出现大波动，说明配置问题。当用户缓存了一份错误的配置，且在下一次获取正确配置之前就使用了错误配置，就会导致用户持续crash，且没有恢复手段。
核心思路便是在每次加载完持久化缓存之后，都从硬盘上清除数据，通过成功进房后获得的配置再次写回磁盘，来破除时间差问题。即使用户缓存了一次错误配置，并且没来得及更新新配置就崩溃，也能在下一次启动时，自动恢复到默认配置的状态，从而能让用户以可用但不理想的状态继续使用app

SetValue:加密数据，计算CRC，存储在缓存中(内存和持久存储)。
GetValue:检索加密数据，检查CRC，如果完整性检查通过，则解密，更新元数据(如读取计数)，并管理缓存。
安全注意事项:
采用AES加密，保证数据安全。
采用CRC校验来验证数据的完整性。
在某些情况下清除缓存数据(n-shot策略)。
总的来说，这段代码提供了一种结构化的方法，通过加密和完整性检查来安全地管理缓存的数据，从而确保了数据处理的可靠性和安全性。

# 插件化
Android md5记录 安装目录 私有目录 外存目录
主库System.load 
插件库 dlopen ---> dlopen成功
1. 库已加载过，则直接跳转至获取函数地址步骤
2. 如果在应用程序中未能找到相应库，则直接加载失败并返回结果至为空
3. 库加载成功后，对其进行记录，并对它的整个生命周期进行管理
4. 调用库中的init方法，对其进行初始化及按需依赖注入（timer\thread\EngineContext\workqueue），把“获取库导出函数地址”的函数地址传递给库，以便库后续使用
5. 获取导出函数的地址并返回，如果失败或找不到则返回空

