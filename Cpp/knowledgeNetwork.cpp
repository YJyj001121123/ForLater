
////网络异步IO https://www.expoli.tech/articles/2023/03/25/what-is-linux-epoll
//同步异步是针对应用程序和内核的交互而言的。
//同步是指用户进程触发IO操作并等待或轮询检查IO操作是否就绪，接着阻塞的完成IO操作
//异步是指用户进程触发IO操作之后就做其它的事情，当IO操作完成之后会得到通知(如读取网络数据，此时数据已经由内核拷贝到用户缓冲区，用户进程可以直接使用)。
//Reactor模式用于同步IO，Proactor模式用于异步IO
////如何打断异步IO
////KCP协议 https://juejin.cn/post/7204770304400490555
//kcp快速可靠的协议，基于UDP
//能以比 TCP 浪费 10%-20% 带宽的代价，换取平均延迟降低 30%-40%，最大延迟降低 3 倍的传输速度。
//纯算法实现，并不负责底层协议（如 UDP）的收发，需要使用者自己定义下层数据包的发送方式，并以 callback 的方式提供给 KCP。
//包括时钟也需要外部传递进来，内部不会有任何一次系统调用
//KCP 整个协议的实现只ikcp.h和ikcp.c两个源文件，可以方便的集成到用户自己的协议栈中。
//比如你实现了一个 P2P，或者某个基于 UDP 的协议
//而缺乏一套完善的 ARQ（自动重传请求，Automatic Repeat-reQuest）实现
// 那么简单的拷贝这两个文件到现有项目中，稍加改造适配，即可使用。
//
//TCP为流量设计（每秒可以传输的数据量），追求利用带宽。TCP信道是流速很慢但是每秒流量大的运河
//KCP为流速设计（单个数据包从一端发送到另一端需要的时间）。KCP小激流
//KCP两种模式正常模式和快速模式（多种策略）ikcp_nodelay
//
///KCP特性：
//RTO（重传超时时间）不会翻倍
//TCP 超时计算是 RTOx2，这样连续丢三次包就变成 RTOx8
//KCP 启动快速模式后不 x2，只是 x1.5（实验证明 1.5 这个值相对比较好），提高了传输速度。
//选择性重传：
//TCP 丢包时会对丢的那个包开始以后的数据全部重传，KCP 则是选择性重传，只重传真正丢失的数据包
//快速重传：
//发送端发送了1,2,3,4,5几个包，然后收到远端的 ACK：1,3,4,5，当收到 ACK3时，KCP 知道2被跳过 1 次，
//收到 ACK4时，知道2被跳过了 2 次
//当次数大于等于设置的 resend 的值的时候，此时可以认为 2号丢失，不用等待超时，直接重传2号包，大大改善了丢包时的传输速度。
//这就是 KCP 的快速重传机制
//ACK + UNA
//UNA（表示此编号之前的所有包已收到，如 TCP）和 ACK（表示此编号包已收到）
//只用 UNA 会导致丢包后只能全部重传，只用 ACK 则丢包后维护成本太高（某个中间包丢掉后，可能需要维护比较多的后续包的缓存），以往协议都是二选其一，
//KCP 协议中，除了单独的 ACK 包外，其他所有包都有 UNA 信息
//
///基本使用
//KCP 的 input/output 方法用来对接下层的 UDP 收发模块
//ikcp_send ickp_recv提供给上层逻辑调用实现

//KCP 的发送和接收单元是 segment，即应用层的数据可能会拆分成多个 segment 发送。
//conv：会话编号。
//cmd：segment 类型，IKCP_CMD_ACK、IKCP_CMD_PUSH、IKCP_CMD_WASK、IKCP_CMD_WINS。
//frg：是否最后一个 segment。0：数据包的最后一个 segment；1：数据包的中间切片 segment。
//sn：下一个待发 segment 的序号。
//una：待接收消息序号，表示这之前的所有 segment 都收到了。
//len：segment 数据长度，不包含头。

///发送端
//在发送端应用层通过 kcp_send 发送数据，KCP 会把用户数据拆分 KCP 数据包，通过 kcp_output 再以 UDP 包的方式发送出去。

//创建kcp对象
// 初始化 kcp对象，conv为一个表示会话编号的整数，和tcp的 conv一样，通信双
// 方需保证 conv相同，相互的数据包才能够被认可，user是一个给回调函数的指针
ikcpcb *kcp = ikcp_create(conv, user);

//设置回调函数
// KCP的下层协议输出函数，KCP需要发送数据时会调用它
// buf/len 表示缓存和长度
// user指针为 kcp对象创建时传入的值，用于区别多个 KCP对象
int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)
{
    ....
}
// 设置回调函数
ikcp_setoutput(kcp, udp_output);

//发送数据
int ikcp_send(ikcpcb *kcp,const char*buffer, int length)

//循环调用update
// 以一定频率调用 ikcp_update来更新 kcp状态，并且传入当前时钟（毫秒单位）
// 如 10ms调用一次，或用 ikcp_check确定下次调用 update的时间不必每次调用
ikcp_update(kcp, millisec);

//接收端
//创建kcp对象

//读取一个下层的数据包、
//收到一个下层数据包（比如UDP包）时需要调用：
ikcp_input(kcp, received_udp_packet, received_udp_size);

//KCP数据还原成发送端发送的 buffer 数据给应用层
int ikcp_recv(ikcpcb *kcp,const char*buffer, int length)


////Websocket协议 https://zhuanlan.zhihu.com/p/581974844 https://juejin.cn/post/6844903604864679943
//websocket 是一个全双工通信的网络技术，属于应用层协议，初始化连接是复用了http的连接通道，底层仍是建立在TCP协议之上的。
//升级：客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议
//数据开销少：协议控制的数据包头部较小，而且支持自定义子协议等

////RTMP协议 https://mp.weixin.qq.com/s?__biz=MjM5MTkxOTQyMQ==&mid=2257484827&idx=1&sn=249da45e5c2c6bff776fe0fdcff42548&chksm=a5d4e04992a3695f0c9472673dbe22917a78cc3d26c934928c95feb13dc87db3bd62966d8cec&scene=21#wechat_redirect



////基础知识
////TCP/IP如何达到可靠传输的 TCp 传输层 iP是网络层
//超时重传：传输过程丢失或者接收检测出错丢弃
//校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
//连续的ARP协议（累积确认/应答）：每个包都有ID，接收方对数据包进行排序，把有序数据传送给应用层
//配合流量和拥塞控制：可变滑动窗口协议 慢开始、拥塞避免、快重传、快恢复
//--为什么三次握手四次挥手
//  三次握手
//  为了防止旧的重复连接初始化造成混乱。
//  同步序列号
//  四次挥手
//  C端发送FIN包，表示客户端不发，还可以接收
//  S端收到FIN，先会回一个ACK，服务端可能还需要处理数据，完毕后再发送FIN给C端，关闭链接
//  TIME_WAIT状态
//  保证TCP协议全双工连接能够可靠关闭
//  保证这次连接的重复数据从网络中消失，如果上次的socket和这次的socket处理的程序一样，就会导致这次连接把上次的数据加进来了
//TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；
//  当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接

////HTTP协议
//建立在TCP/IP协议上。应用层协议，默认端口号是 80。
//无状态:浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。
//keep-alive 用户态，是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；
//以 ASCII 码传输
//规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体
//--HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，
//  分别是GET，POST，PUT，DELETE 查 增 改 删
//  GET: URL中受URL限制 它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态
//  POST: HTTP包内 可能修改变服务器上的资源的请求，会增加种类
//  PUT: 向服务器端发送数据的，从而改变信息，不会增加数据的种类。
//  PATCH: 类似PUT，资源部分的更新
//--Header常见Key
//  Cookie Host Date Connection
//HTTP传输二进制 base64加解密
//HTTPS加密的
//客户端发起ssl请求，服务端返回CA证书
//客户端解析证书验证真伪，获取用于非对称加密的公钥
//利用公钥加密发送对称加密的私钥
//利用对称加密传输数据

////TCP和UDP
// TCP是面向连接且可靠的，UDP是面向非连接且非可靠
// TCP是面向字节流的，UDP是面向报文流
// TCP的传输效率低，UDP传输效率高
// TCP有流量控制，拥塞控制等，UDP没有
// TCP适用于对可靠性要求比较高，但对效率要求低的场景，而UDP适用于对可靠性要求比较低，但对效率要求比较高的场景
// TCP协议应用: HTTP/FTP/TELNET/SMTP UDP协议应用: DNS/SNMP

////输入url地址到页面显示的过程 https://zhuanlan.zhihu.com/p/133906695
//输入地址：可能匹配url 或者缓存 网页显示
//浏览器查找域名ip：
//   解析域名+查看硬盘的hosts文件，看是否有缓存
//   如果没有缓存，浏览器发起DNS请求到本地的DNS服务器，网络接入商（电信）
//   本地DNS服务器递归查询，DNS根服务器 域服务器  DNS 域名到ip的解析
//     DNS负载均衡技术:DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡
//浏览器向web服务器发送HTTP请求
//   浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求
//服务器的永久重定向响应
//   服务器给浏览器响应一个301永久重定向响应
//服务器处理请求---请求发送到了服务器
//   反向代理服务器Nginx
//服务器返回一个 HTTP 响应
//浏览器显示 HTML
//浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）